# TIMER A Blink - MSP430G2553 & MSP430F5529
The files provided in this folder are **timer1.c** and **timer2.c** that both uses interrupts and timer modules to toggle an LED with different control speeds in the development boards. The MSP430G2553 c.file is named timer1.c and the MSP430F5529 c.file is named timer2.c. 

### MSP430G2553 TimerA
**Description** : This code blinks two LEDs connected to P1.0 and P1.6 using an interrupt generated by the timer module. The green and red LEDs blink at rate of 0.5 Hz and 0.25 Hz, respectively. The TimerA module is used in continuous mode with an ACLK source and overflow interrupt. The LEDs P1.0 and P1.6 are set as outputs and the TACCR0 interrupt is enabled. 
```c 
  TA0CTL |= TASSEL_1 + MC_2 + TAIE; //Start Timer with ACLK clock source, Continuous mode and enable overflow interrupt

  __bis_SR_register(LPM0_bits + GIE); // Enable the global interrupt and enter LPM0
```
There are two ISR one for Timer_A0 and the other for Timer_A1. The Timer_A0 is first prioritized and toggles the green LED with an added offset to TACCR0 of 32768. TA_0 ISR is then triggered every 32768 cycles and the ISR TA_1 is triggered after overflow from the timer counter -> 65525 counts. 

```c
// Timer A0 interrupt service routine
#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A0 (void)
{
  P1OUT ^= BIT0;  // Toggle P1.0
  TACCR0 += 32768;  // Add offset to CCR0
  // toggle rate = 32768 / (2*32768) = 0.5Hz
}


// Timer A1 interrupt service routine
#pragma vector=TIMER0_A1_VECTOR
__interrupt void Timer_A1 (void)
{
    switch(TAIV) // switch
{
    case 2: // Do nothing
        break;

    case 4: // Do nothing
        break;

    case 10:
        P1OUT ^= BIT6; // Toggle P1.6
        // toggle rate =  32768/(2*65536) = 0.25Hz
        break; // Overflow
}
```
The toggle rate of the green LED is calculated by taking the offset added value from TA0CCR0 (32768 Hz) and dividing it by (2*32768).
The toggle rate of the green LED is equal 0.5Hz.The second ISR is processed through the Timer_A interrupt vector register or TAIV, and
is used to prioritize and combine the remaining interrupt flags. When reading the TAIV it will give the value of the current interrupt,
as well as clearing that interrupts flag. The red LED is toggle at a rate of 0.25Hz. The value is calculated by taken 32768 and dividing
it by (2*65536). The values 65536 Hz is the maximum counter for the timer.

### MSP430F5529 TimerA
**Description** : This code blinks two LEDs connected to P1.0 and P4.7 on the MSP430F5529 board. The TA0CCR0 is valued at 20000 to count up at this value before it drops to 0. The TimerA module is used in up mode with an ACLK source and pre-divider of 2. 

```c
    TA0CTL = TASSEL_1 + MC_1 + ID_1;  // ACLK, Up Mode (Counts to TA0CCR0), ID_1: 20000/2 = 10000Hz

    _BIS_SR(LPM0_bits + GIE);  // Enter Low power mode 0 with interrupts enabled

```
The divider takes 20000 and divides it by 2 -> 10000. The new value for TA0CCR0 is 10000. In Timer0 A0 interrupt service routine (ISR) the red LED is toggle first at a rate of 10000 / (2*10000) = 0.5Hz and the interrupt is triggered at 12kHz / 20000 = 0.6 -> 1/0.6 = 1.67 secs. The green LED will trigger after 2 flashes later because of the counter placed inside the ISR (0.5 * 4 = 2).

```c
#pragma vector=TIMER0_A0_VECTOR  // Timer0 A0 interrupt service routine
   __interrupt void Timer0_A0 (void)
   {

        i++;
        P1OUT ^= BIT0;  // P1.0 Toggle (Red LED)

       if (i == 4)
       {
        P4OUT ^= BIT7;  // P4.7 Toggle (Green LED)
        i = 0;
       }
   }
```
### Watchdog Timers
Both are set to have their watchdog timers off so that the controllers do not reset everytime when they're using interrupts. In fact, watchdog timers keeps track of any abnormal behavior from the program. If the program fails and it "crashes," then the watchdog timer will trigger a reset and force the program back to the beginning. This needs to be disable so that the function of the code works.
