/* Rowan University
 * File: timer1.c
 * Author: Jan Garcia
 * Course: Intro to Embedded Systems
 * Section: 1
 * Creation Data: 9/25/18
 * Lab 2 - TimerA Blink
 * Board - MSP430G2553
 *
 * Description: This code blinks two LEDs connected to P1.0 and P1.6 using an interrupt generated by the timer module.
 * The green and red LEDs blink at rate of 0.5 Hz and 0.25 Hz, respectively.
 *
 * The TimerA module is used in continuous mode with an ACLK source and overflow interrupt.
 * There are two ISR one for Timer_A0 and the other for Timer_A1. The Timer_A0 is first prioritized and
 * toggles the green LED with an added offset to CCR0 of 32768. TA_0 ISR is then triggered every 32768 cycles and
 * the ISR TA_1 is triggered after overflow from the timer counter -> 65525 counts. The toggle rate of the green LED is
 * calculated by taking the offset added value to TA0CCR0 32768 and dividing it by (2*32768) = 0.5Hz.
 *
 * The second ISR is processed through the Timer_A interrupt vector register or TAIV, and is used to prioritize and
 * combine the remaining interrupt flags. When reading the TAIV it will give the value of the current
 * interrupt, as well as clearing that interrupts flag. The red LED is toggle at a rate of 0.25Hz.
 *  The value is calculated by taken 32768 and dividing it by (2*65536). 65536 is the max count for the timer.
 */

#include <msp430.h> 

void main(void)
{
  WDTCTL = WDTPW + WDTHOLD; // Stop WDT
  P1DIR |= BIT0;  // P1.0 set as output
  P1DIR |= BIT6;  // P1.6 set as output
  P1OUT &= ~(BIT0);  // Turn Green LED OFF
  P1OUT &= ~(BIT6);  // Turn Red LED OFF


  TA0CCTL0 = CCIE; // Enable CCR0 interrupt

  TA0CCR0 = 0; // // Counter value: 0 Hz

  TA0CTL |= TASSEL_1 + MC_2 + TAIE; //Start Timer with ACLK clock source, Continuous mode and enable overflow interrupt

  __bis_SR_register(LPM0_bits + GIE); // Enable the global interrupt and enter LPM0

}

// Timer A0 interrupt service routine
#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A0 (void)
{
  P1OUT ^= BIT0;  // Toggle P1.0
  TACCR0 += 32768;  // Add offset to CCR0
  // toggle rate = 32768 / (2*32768) = 0.5Hz
}


// Timer A1 interrupt service routine
#pragma vector=TIMER0_A1_VECTOR
__interrupt void Timer_A1 (void)
{
    switch(TAIV) // switch
{
    case 2: // Do nothing
        break;

    case 4: // Do nothing
        break;

    case 10:
        P1OUT ^= BIT6; // Toggle P1.6
        // toggle rate =  32768/(2*65536) = 0.25Hz
        break; // Overflow
}
}

